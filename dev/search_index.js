var documenterSearchIndex = {"docs":
[{"location":"dynamic/#Development-over-time","page":"Dynamic analysis","title":"Development over time","text":"","category":"section"},{"location":"dynamic/#Constructing-a-sequence-of-events","page":"Dynamic analysis","title":"Constructing a sequence of events","text":"","category":"section"},{"location":"dynamic/","page":"Dynamic analysis","title":"Dynamic analysis","text":"The central function for analysing development over time is fill_sequence, which computes a sequence of SpillEvents that describe how water accumulates, flows and drains on a terrain over time, considering infiltration and potentially changing weather conditions.","category":"page"},{"location":"dynamic/","page":"Dynamic analysis","title":"Dynamic analysis","text":"Modules = [SurfaceWaterIntegratedModeling]\nPages = [\"fill_sequence.jl\"]","category":"page"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.fill_sequence-Tuple{TrapStructure, Vector{WeatherEvent}}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.fill_sequence","text":"fill_sequence(tstruct, weather_events, time_slack=0.0, infiltration=nothing, verbose=false)\n\nCompute the sequence of events that describes how water on the terrain evolves over time.\n\nFor a given set of weather events, and a given terrain with associated trap structure, determine the sequence of events that describes how the flow and accumulation of water on the terrain changes over time.\n\nReturns a Vector{SpillEvent} that expresses the discrete points in time when different traps fills/empties, and the resulting changes on the surface flow patterns.\n\nArguments\n\ntstruct::TrapStructure{Real}: trap structure object describing the terrain traps\nweather_events::Vector{WeatherEvent}: Vector of weather events describing                                         changes in weather over time\ntime_slack::Real: tolerance for when to merge events that are close to each other                     in time.  Should be set to zero or a small number.                     @@ NB: Support for this currently unimplemented.\ninfiltration::Union{Matrix{Real}, Nothing}:                      grid of same shape as the terrain, giving the infiltration rate                     at each gridcell.\nverbose::Bool: if true, dump progress information during computation\n\nSee also TrapStructure, WeatherEvent, SpillEvent\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#Associated-structs-and-functions","page":"Dynamic analysis","title":"Associated structs and functions","text":"","category":"section"},{"location":"dynamic/","page":"Dynamic analysis","title":"Dynamic analysis","text":"Modules = [SurfaceWaterIntegratedModeling]\nPages = [\"weatherevent.jl\", \"spillevent.jl\", \"spillgraph.jl\", \"rateinfo.jl\", \"flow.jl\"]","category":"page"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.WeatherEvent","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.WeatherEvent","text":"WeatherEvent\n\nA struct representing a weather event, i.e. a change of weather.\n\nFields\n\ntimestamp::Float64: Start time point of the weather event\nrain_rate::Union{Matrix{Float64}, Float64}:      Rain rate set by the event.  It can be given either as a single     floating-point number that represents a uniform rate across the      terrain, or a matrix of floating-point number for individual rain rates     per grid cell.\n\nThe unit of rain rate is given in topographical grid height unit per time unit. E.g., if the topography is presented in a height unit of meters, and time is  counted in hours, then the specified rate value will be interpreted as meters  per hour.\n\nSee also fill_sequence, which takes a Vector{WeatherEvent} as one of its inputs.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.ChangeTimeEstimate","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.ChangeTimeEstimate","text":"Structure used when estimating when a SpillEvent will occur, i.e. when a given non-filled trap will completely fill up, or a given filled trap  will start emptying.  \n\nThe structure provides an upper and lower bound for when this event should happen.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.FilledAmount","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.FilledAmount","text":"Structure specifying that a trap will contain an amount volume of water at  timepoint time.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.IncrementalUpdate","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.IncrementalUpdate","text":"Structure specifying an incremental update in the quantity of something.  It is  used in several different settings.  It contain an index (to refer to a specific  element to be updated) and a corresponding value (the value to update).\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.SpillEvent","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.SpillEvent","text":"struct SpillEvent\n\nA struct representing a \"spill event\", i.e. a moment in time when a trap changes its fill status.  A trap can either transitory or filled, and the spill event refers to the moment in time when the trap passes from one to the other.\n\nFields\n\ntimestamp::Float64: the time when the event occurs\namount::Union{Vector{FilledAmount}, Vector{IncrementalUpdate{FilledAmount}}}:   amount of water in the traps.  Can be presented as a vector with one entry per  trap, or as a vector of incremental updates to certain traps (as compared to the  last registered SpillEvent).\nfilled::Union{Vector{Bool}, Vector{IncrementalUpdate{Bool}}}:      the traps that are filled when the event occurs.  Can be presented as a vector      with one (boolean) value per trap, or as an incremental update representing     the change since last registered SpillEvent.\ninflow::Union{Vector{Float64}, Vector{IncrementalUpdate{Float64}}}:      water inflow to each trap, presented either as a vector with the individual     values of each and every trap, or as a set of incremental updates representing     the change since the last registered SpillEvent.  Inflow is a combination of     direct presipitation, runoff from the trap's watershed or spillover from      upstream overflowing traps.\nrain_rate::Union{Matrix{Float64}, Float64, Nothing}:      if this event consisted of a weather change, it will be represented here,      either as a single floating point value (considered constant over the grid),     or as a grid with individual values for each cell.\nrunoff::Union{Matrix{Float64}, Vector{IncrementalUpdate{Float64}}}:      matrix keeping track of current overland flow and infiltration rate for each     gridcell.  Positive values represent overland flow, negative values infiltration.     Can be presented either as a matrix with values for each and every grid cell,     or as a set of incremental changes compared with last SpillEvent.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.amount_at","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.amount_at","text":"amount_at(seq, end_ix=-1)\n\nGiven a sequence of chronological SpillEvents seq, determine the FilledAmount for each trap at the end of the sequence (end_ix=-1), or at an earlier  event (end_ix ∈ [1:length(seq)]).  \n\nThis function computes its result by running through the sequence and accumulating differences until it has identified the correct entry for all traps.\n\nNote that the returned FilledAmount for each trap does not necessarily correspond to the timestamp of the corresponding FillEvent, but may represent a value computed for an earlier point in time.  The RateInfo for that trap  should however have remained constant since the last time the value was computed, so it should be relatively straightforward to compute the present value if needed.\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.filled_at","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.filled_at","text":"filled_at(seq, end_ix=-1)\n\nGiven a sequence of chronological SpillEvents seq, determine which traps are  filled at the end of the sequence (end_ix=-1), or at an earlier  event (end_ix ∈ [1:length(seq)]).  \n\nThis function computes its result by running through the sequence and accumulating differences until it has identified the correct entry for all traps.\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.inflow_at","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.inflow_at","text":"inflow_at(seq, end_ix=-1)\n\nGiven a sequence of chronological SpillEvents seq, determine the rate of water flowing into a trap (from its watershed, from upstream, or directly from  precipitation) at the end of the sequence (end_ix=-1), or at an earlier  event (end_ix ∈ [1:length(seq)]).  \n\nThis function computes its result by running through the sequence and accumulating differences until it has identified the correct entry for all traps.\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.rainrate_at","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.rainrate_at","text":"rainrate\\_at(seq, end_ix=-1)\n\nGiven a sequence of chronological SpillEvents seq, determine the rain rate in effect at the end of the sequence (end_ix=-1), or at an earlier event  (end_ix ∈ [1:length(seq)]).  \n\nThis function computes its result by running through the sequence and identifying the latest rainrate that went into effect before the sequence entry specified by end_ix.\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.runoff_at","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.runoff_at","text":"runoff_at(seq, end_ix=-1)\n\nGiven a sequence of chronological SpillEvents seq, determine the runoff  across each point of the terrain (i.e. each gridcell) at the end of the sequence  (end_ix=-1), or at an earlier event (end_ix ∈ [1:length(seq)]).  \n\nPositive values represent infiltration excess flow (runoff), whereas negative values represent remaining infiltration capacity.\n\nThis function computes its result by running through the sequence and accumulating differences until it has identified the correct entry for all traps.\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.SpillGraph","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.SpillGraph","text":"mutable struct SpillGraph\n\nA struct representing a tree-like spillgraph.  It specifies how water flow from one (filled) trap to the next.  When a trap is filled, it may spill into its downstream trap, or into its parent trap (depending on whether it shares a parent with its downstream trap, and the downstream trap is filled).\n\nThe spill graph is recorded as a set of edges, stored in the Dict edges, so that if trap 'i' spills into trap 'j', then edges[i] = k.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.SpillGraph-Tuple{}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.SpillGraph","text":"Default constructor for SpillGraph creates an empty spillgraph.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.compute_complete_spillgraph-Union{Tuple{T}, Tuple{TrapStructure{T}, Vector{Bool}}} where T<:Real","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.compute_complete_spillgraph","text":"compute_complete_spillgraph(tstruct, full_traps)\n\nCompute the complete spillgraph, given a trapping structure and a (sub)set of filled traps.\n\nReturns an object of type SpillGraph.  \n\nThe full_traps vector must be consistent, i.e. no filled trap can have non-filled subtraps.\n\nArguments\n\ntstruct::TrapStructure{T<:Real}: trapping structure\nfull_traps::Vector{Bool}: a vector with one entry per trap, specifying if that                             trap has been completely filled or not.\n\nSee also TrapStructure, update_spillgraph!.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.get_graph-Tuple{SpillGraph}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.get_graph","text":"get_graph(spill_graph)\n\nConverts the SpillGraph spill_graph into a Graphs.SimpleDiGraph from the Graphs package (https://juliagraphs.org).\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.update_spillgraph!-Union{Tuple{T}, Tuple{SpillGraph, Vector{IncrementalUpdate{Bool}}, TrapStructure{T}}} where T<:Real","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.update_spillgraph!","text":"update_spillgraph!(spillgraph, fill_changes, tstruct)\n\nUpdate an existing spillgraph after there have been changes in which traps are filled or not.\n\nThe argument spillgraph will be modified.\n\nArguments\n\nspillgraph::SpillGraph: the spillgraph to be updated\nfill_changes::Vector{IncrementalUpdate{Bool}}: changes in the fill status of       one or more traps, presented as a vector of incremental updates\ntstruct::TrapStructure{T<:Real}: the TrapStructure representing the      trapping structure of the terrain the spill graph is associated with\n\nSee also IncrementalUpdate, SpillGraph and  compute_complete_spillgraph.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.RateInfo","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.RateInfo","text":"RateInfo\n\nA mutable struct representing rates of water (inflow, infiltration) associated with the terrain and its traps.\n\nThe fields of this struct should in general not be accessed directly, but through the set of associated methods, listed below. \n\nFields\n\nrunoff::Matrix{Float64}: net overland flow or remaining infiltration capacity,                             one value per gridcell in the terrain grid.\nSmax::Vector{Float64}: maximum remaining infiltration within trap footprint, one                          value per trap.\nSmin::Vector{Float64}: minimum infiltration within trap footprint, one value                          per trap. (Only nonzero for traps with subtraps, and then                           equals the sum of Smax for its subtraps).\ntrap_inflow::Vector{Float64}: total inflow to each trap.\nstored_runoff_values::Dict{Int,Float64}: if values have changed and save_active                                            is set to true, this field stores the                                            original runoff values for those that                                             were later modified.\nstored_Smin_values::Dict{Int,Float64}: if values have changed and save_active                                            is set to true, this field stores the                                            original Sminvalues for those that                                             were later modified.\nstored_Smax_values::Dict{Int,Float64}: if values have changed and save_active                                            is set to true, this field stores the                                            original Smax values for those that                                             were later modified.\nstored_inflow_values::Dict{Int,Float64}: if values have changed and save_active                                            is set to true, this field stores the                                            original Smax values for those that                                             were later modified.\nsave_active::Bool: flag specifying if the initial state should be preseved.\n\nAssociated methods for access\n\ngetrunoff\ngetsmin\ngetsmax\ngetinflow\nsetrunoff!\nsetsmin!\nsetsmax!\nsetinflow!\nsetsavepoint!\ndisablesavepoint!\ngetsavedrunoff\ngetsavedsmin\ngetsavedsmax\ngetsavedinflow\ngetrunoffupdates\ngetinflowupdates \n\nConstructor\n\nRateInfo(runoff, Smax, Smin, trap_inflow)\n\nCreates a new RateInfo object with the provided parameters.\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#Base.copy-Tuple{RateInfo}","page":"Dynamic analysis","title":"Base.copy","text":"A copy of a RateInfo object is always a deep copy.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.disablesavepoint!-Tuple{RateInfo}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.disablesavepoint!","text":"Disable the current savepoint.  Saved state will no longer be maintained.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getinflow-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getinflow","text":"Get the current inflow value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getinflowupdates-Tuple{RateInfo}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getinflowupdates","text":"Get a vector with the inflow updates that have occured since the last savepoint was set.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getrunoff-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getrunoff","text":"Get the current runoff value for the gridcell with linear index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getrunoffupdates-Tuple{RateInfo}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getrunoffupdates","text":"Get a vector with the runoff updates that have occured since last savepoint was set.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsavedinflow-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsavedinflow","text":"Get the saved inflow value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsavedrunoff-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsavedrunoff","text":"Get the saved runoff value for the gridcell with linear index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsavedsmax-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsavedsmax","text":"Get the saved Smax value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsavedsmin-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsavedsmin","text":"Get the saved Smin value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsmax-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsmax","text":"Get the current Smax value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.getsmin-Tuple{RateInfo, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.getsmin","text":"Get the current Smin value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.setinflow!-Tuple{RateInfo, Any, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.setinflow!","text":"Set the current inflow value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.setrunoff!-Tuple{RateInfo, Any, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.setrunoff!","text":"Set the current runoff value for the gridcell with linear index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.setsavepoint!-Tuple{RateInfo}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.setsavepoint!","text":"Set the savepoint here. (State at this point will be remembered, even in the face of later updates, until the savepoint is reset or disabled).\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.setsmax!-Tuple{RateInfo, Any, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.setsmax!","text":"Set the current Smax value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.setsmin!-Tuple{RateInfo, Any, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.setsmin!","text":"Set the current Smin value for the trap with index 'ix'.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling._propagate_amount!-NTuple{5, Any}","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling._propagate_amount!","text":"will modify rateinfo \n\n\n\n\n\n","category":"method"},{"location":"dynamic/#SurfaceWaterIntegratedModeling.compute_flow","page":"Dynamic analysis","title":"SurfaceWaterIntegratedModeling.compute_flow","text":"compute_flow(spillgraph, precipitation, infiltration, tstruct, verbose=false)\n\nFor a given spillgraph, precipitation and infiltration rates, compute the runoff and trap inflows, in the form of a RateInfo object.\n\nArguments\n\nspillgraph::SpillGraph: the current spillgraph, i.e. a tree graph representing                            which traps spill into which\nprecipitation::Union{Real, Matrix{<:Real}}: specifies the precipitation rate.        Can be given either as a single scalar, or cell-wise in the form of a Matrix\ninfiltration::Union{Real, Matrix{<:Real}}: specifies the infiltration rate.       Can be given either as a single scalar, or cell-wise in the form of a Matrix\ntstruct::TrapStructure{<:Real}: object representing the trap sturcture\nverbose::Bool: if true, dump progress information during computation\n\nSee also SpillGraph, TrapStructure.\n\n\n\n\n\n","category":"function"},{"location":"static/#Static-topographic-analysis","page":"Static analysis","title":"Static topographic analysis","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"This page contains the documentation of the main functions related to the static analysis.","category":"page"},{"location":"static/#TrapStructure","page":"Static analysis","title":"TrapStructure","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The TrapStructure contains all the fundamental results from running spillanalysis.  This includes the identified traps, their volumes, footprints, how they are connected, and the associated watersheds and spill point locations. TrapStructure also contains the spillfield (how flow is directed between gridcells), as well as a copy of the topography, buildings and sinks that went into the analysis.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules = [SurfaceWaterIntegratedModeling]\nPages = [\"TrapStructure.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.TrapStructure","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.TrapStructure","text":"struct TrapStructure{T<:Real}\n\nA struct representing a watershed drainage trap for topographical analysis.\n\nFieldnames\n\ntopography::Matrix{T}: raster grid of terrain height values.\nspillfield::Matrix{Int8}: local direction of streamline (see spillfield)\nregions::Matrix{Int}: raster grid with region numbers (see spillregions)\nspillpoints::Vector{Spillpoint}: vector with spill point information per trap                                    (see spillpoints)\ntrapvolumes::Vector{T}: computed trap volumes (see trapvolumes)\nsubvolumes::Vector{T}: the part of each trap's volume that is fully contained within                          its subtraps\nfootprints::Vector{Vector{Int}}: one entry per trap, listing the (linear) indices                                    of all its cells \nlowest_subtraps_for::Vector{Vector{Int}}: one entry per trap, listing all its                                             lowest-level subtraps\nsupertraps_of::Vector{Vector{Int}}: one entry per lowest-level trap, listing all                                       the supertraps it belongs to (including itself).\nagglomerations::Graphs.SimpleDiGraph: hierarchy of sub/supertraps, presented as a                                         graph structure\nbuilding_mask::Union{Matrix{Bool}, Nothing}: building mask (0: terrain, 1: building)\nsinks::Union{Vector{Tuple{Int, Int}}, Nothing}: list of sinks, in term of grid                                                   cell coordinates\n\n\n\n\n\n","category":"type"},{"location":"static/#SurfaceWaterIntegratedModeling.numregions-Tuple{TrapStructure}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.numregions","text":"numregions(tstruct)\n\nReturns the number of regions identified in the TrapStructure tstruct. The number of regions is identical to the number of lowest-level traps.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.numtraps-Tuple{TrapStructure}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.numtraps","text":"numtraps(tstruct)\n\nReturns the number of traps identified in the TrapStructure tstruct. This includes the lowest-level traps as well as all higher-level traps.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.parentof-Tuple{TrapStructure, Int64}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.parentof","text":"parentof(tstruct, trap_ix)\n\nGiven a TrapStructure tstruct, returns the index of the parent trap (immediate higher-level trap) of the trap indexed trap_ix.  If this trap does  not have a parent trap, nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.subtrapsof-Tuple{TrapStructure, Int64}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.subtrapsof","text":"subtrapsof(tstruct, trap_ix)\n\nGiven a TrapStructure tstruct, returns the indices to the immediate subtraps of the trap indexed trap_ix. This is usually zero or two, but can be higher than two in degenerate cases.\n\n\n\n\n\n","category":"method"},{"location":"static/#Spill-analysis","page":"Static analysis","title":"Spill analysis","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The function spillanalysis runs a complete analysis on a provided terrain grid and associated buildings and sinks, and returns a TrapStructure as output.  This is the central function for static topographic analysis in SWIM.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules = [SurfaceWaterIntegratedModeling]\nPages = [\"spillanalysis.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.spillanalysis-Tuple{Matrix{<:Real}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.spillanalysis","text":"spillanalysis(grid, usediags=true, building_mask=nothing, sinks=nothing,\n              lengths=nothing, domain=nothing, merge_outregions=false, \n              verbose=false)\n\nAnalyse a terrain and compute all key information regarding its trap structure.\n\nThis information includes the spillfield, all the spill regions, traps with their  volumes, spillpoints and footprints, the upstream/downstream trap hierarchy,  and the supertrap/subtrap hierarchy.  \n\nAll computed information is returned as a TrapStructure.  Refer to its documentation for details.\n\nArguments\n\ngrid::Matrix{<:Real}: topograpical grid to analyse\nusediags::Bool: if true, also consider slopes along diagonals\nbuilding_mask::Union{Matrix{<:Bool}, BitMatrix, Nothing}:      if present, provides a mask that specifies the footprint of buildings.       These parts of the domain will be clipped away.\nsinks::Union{Vector{Tuple{Int, Int}}, Matrix{Bool}, Nothing}:     vector containing (i, j) grid coordinates of any point sinks in the grid, if any.     Can also be a Matrix{Bool} of same size as grid, indicating the sink locations.\nlengths::Union{Tuple{<:Real}, Nothing}:      tuple expressing the length and width of the grid (used to compute aspect ratios)\ndomain::Union{Domain2D, Nothing}:      restrict computation to the specified domain of the grid.  @@ Note that this is not     fully supported yet for this function.\nmerge_outregions::Bool: if true, all \"outside\" regions will be merged and      represented as region -1.   Otherwise, each \"outside\" region will be represented     by its own negative integer.\nverbose::Bool: if true, print information showing progress in the computation                   along the way.\n\nSee also TrapStructure, fill_sequence.\n\n\n\n\n\n","category":"method"},{"location":"static/#Lower-level-functions","page":"Static analysis","title":"Lower-level functions","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The functions listed below are used by the spillanalysis function.  They can however also be run independently.","category":"page"},{"location":"static/#Spillfield","page":"Static analysis","title":"Spillfield","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The spillfield function computes the basic gravity-driven flow pattern on a terrain.  For each cell, it determines the direction of flow and the correpsonding neighbor downstream cell, using either a 4-element or 8-element stencil.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"spillfield.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling._spillfield!-Tuple{Matrix{Int8}, Array{<:Real}, Matrix{<:Real}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling._spillfield!","text":"_spillfield!(dir, slope, grid, usediags=true, lengths=nothing)\n\nMutating version of spillfield.  The results 'dir' and 'slope' are not returned, but passed as arguments.  See documentation of 'spillfield' for a general description.  A key difference in the mutating version is that the results (dir and slope) retain the full size of the grid, even though only a subdomain is addressed.  (In the non-mutating version, the returned grids are limited to the size of the addressed subdomain.)\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.hconcat_spillfields-Tuple{Matrix{Int8}, Matrix{<:Real}, Matrix{<:Real}, Matrix{Int8}, Matrix{<:Real}, Matrix{<:Real}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.hconcat_spillfields","text":"hconcat_spillfields(dir1, slope1, grid1, dir2, slope2, grid2, usediags=true, \n                    lengths=nothing)\n\nConcatenate two spill fields along the 'horizontal' direction (adding columns).\n\nIn addition to the spill fields dir1 and dir2 to concatenate, the corresponding slopes and original terrain grids are also given (slope1, slope2,  grid1, grid2).  These are used to re-compute the spill directions for  gridcells on the 'seam' between the two spill fields.\n\nThe function returns the combined spill field (corresponding to [dir1, dir2]), as  well as the associated slopes (corresponding to [slope1, slope2])\n\nArguments\n\ndir1::Matrix{Int8}: first spill field\nslope1::Matrix{<:Real}: matrix with local slopes for first spill field\ngrid1::Matrix{<:Real}: topography grid from which dir1 was computed\ndir2::Matrix{Int8}:  second spill field\nslope2::Matrix{<:Real}: matrix with local slopes for second spill field\ngrid2::Matrix{<:Real}: topography grid from which dir2 was computed\nusediags::Bool: if true, also consider slopes along diagonals\nlengths::Union{Tuple{<:Real}, Nothing}:      tuple expressing the length and width of the combined grid (used to compute     aspect ratios)\n\nSee also spillfield, vconcat_spillfields.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.spillfield-Tuple{Matrix{<:Real}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.spillfield","text":"spillfield(grid, usediags=true, lengths=nothing, domain=nothing, \n           tiling=nothing, building_mask=nothing)\n\nCompute the spillfield of a raster terrain, represented by grid.  \n\nThe spillfield is returned an integer array of same shape as grid, to be interpreted as follows: \n\n-3 : sink (any passing streamline is terminated here)\n-2 : covered by building / clipped away\n-1 : no downward slope (gridcell is a trap)\n0 : steepest slope towards (i-1, j)\n1 : steepest slope towards (i+1, j)\n2 : steepest slope towards (i, j-1)\n3 : steepest slope towards (i, j+1)\n4 : steepest slope towards (i-1, j-1)\n5 : steepest slope towards (i+1, j+1)\n6 : steepest slope towards (i+1, j-1)\n7 : steepest slope towards (i-1, j+1)\n\nTrap bottoms, i.e. cells for which there exists no downward slope, are given the value -1.\n\nIn addition, a matrix with the value of the steepest slope in each point is returned as a second argument.   \n\nArguments\n\ngrid::Matrix{<:Real}: terrain raster grid with height values\nusediags::Bool: if true, also consider slopes along diagonals\nbuilding_mask::Union{Matrix{Bool}, BitMatrix, Nothing}:      a grid of logicals, specifying which cells are masked by buildings (true),      and thus inactive. These cells will be assigned a spill field value of -2     (see list above).\nsinks::Union{Vector{Tuple{Int, Int}}, Nothing}:      vector containing (i, j) grid coordinates of any point sinks in the grid, if any\nlengths::Union{Tuple{<:Real}, Nothing}:      tuple expressing the length and width of the grid (used to compute aspect ratios)\ndomain::Union{Domain2D, Nothing}: restrict computation to the specified domain                                     of the grid\ntiling::Union{Tuple{Int, Int}, Nothing}:      tuple specifying number of 'tiles' to subdivide surface in for parallel     processing.  Default is (1,1), which means the whole surface is treated     as a single tile (no parallel processing).\n\nSee also update_spillfield!.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.update_spillfield!-Tuple{Matrix{Int8}, Array{<:Real}, Matrix{<:Real}, Domain2D}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.update_spillfield!","text":"update_spillfield!(dir, slope, grid, domain, usediags=true, lengths=nothing)\n\nUpdate an existing spill field in-place within a specific rectangular domain (where  the topography grid has presumably changed).\n\nArguments\n\ndir::Matrix{Int} : the spillfield, as described in the documentation of the                      spillfield function.  Will be updated within the                      specified domain.\nslope::Array{<:Real}: the steepest slope in each grid point, as returned by                         the spillfield function.  Will be updated within the                         specified domain.\ngrid::Matrix{<:Real}: terrain raster grid with height values.  This grid has                         presumably already been changed within the specified                          domain.\ndomain::Domain2D : the domain in which to update the information in dir                       and slope\nusediags::Bool=true: if true, also consider slopes along diagonals\nlengths::Union{Tuple{<:Real}, Nothing}:      tuple expressing the length and width of the grid (used to compute aspect ratios)\nbuilding_mask::Union{Matrix{Bool}, Nothing}:      a grid of logicals, specifying which cells are masked by buildings (true),      and thus inactive. These cells will be assigned a spill field value of -2      (see list of possible fieldvalues in documentation of spillfield.)\nsinks::Vector{Union{Tuple{Int, Int}, Nothing}}:      vector containing (i, j) grid coordinates of any point sinks in the grid, if any.\n\nSee also spillfield.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.vconcat_spillfields-Tuple{Matrix{Int8}, Matrix{<:Real}, Matrix{<:Real}, Matrix{Int8}, Matrix{<:Real}, Matrix{<:Real}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.vconcat_spillfields","text":"vconcat_spillfields(dir1, slope1, grid1, dir2, slope2, grid2, usediags=true, \n                    lengths=nothing)\n\nConcatenate two spill fields along the 'vertical' direction (adding rows).\n\nIn addition to the spill fields dir1 and dir2 to concatenate, the corresponding slopes and original terrain grids are also given (slope1, slope2,  grid1, grid2).  These are used to re-compute the spill directions for  gridcells on the 'seam' between the two spill fields.\n\nThe function returns the combined spill field (corresponding to [dir1; dir2]), as  well as the associated slopes (corresponding to [slope1; slope2])\n\nArguments\n\ndir1::Matrix{Int8}: first spill field\nslope1::Matrix{<:Real}: matrix with local slopes for first spill field\ngrid1::Matrix{<:Real}: topography grid from which dir1 was computed\ndir2::Matrix{Int8}:  second spill field\nslope2::Matrix{<:Real}: matrix with local slopes for second spill field\ngrid2::Matrix{<:Real}: topography grid from which dir2 was computed\nusediags::Bool: if true, also consider slopes along diagonals\nlengths::Union{Tuple{<:Real}, Nothing}:      tuple expressing the length and width of the combined grid (used to compute     aspect ratios)\n\nSee also spillfield, hconcat_spillfields.\n\n\n\n\n\n","category":"method"},{"location":"static/#Spillregions","page":"Static analysis","title":"Spillregions","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"For a given spillfield (as computed by the spillfield function), the spillregions function separates the terain into individual watersheds, each associated with a local minimum in the terrain surface. ","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"spillregions.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.spillregions-Tuple{Matrix{Int8}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.spillregions","text":"spillregions(spillfield)\n\nIdentify all spill regions to be derived from a given spillfield.\n\nA spill region is a group of cells that flow into the same trap (here: the lowest-level traps).\n\nReturns a Matrix{Int} of the same shape as spillfield, where all cells with the same integer value belong to the same spill region.  Spill regions that  exit the domain are assigned negative region numbers.\n\nArguments\n\nspillfield::Matrix{Int}: the matrix containing the spillfield already                             computed from the spillfield function.\nusediags : if true, diagonal connections between cells will also be considered\ntiling::Union{Tuple{Int, Int}, Nothing}:      tuple specifying number of 'tiles' to subdivide surface in for parallel      processing.  Default is (1,1), which means the whole surface is treated     as a single tile (no parallel processing).\n\nSee also spillfield, update_spillregions!.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.update_spillregions!-Tuple{Matrix{Int64}, Matrix{Int8}, Domain2D}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.update_spillregions!","text":"update_spillregions!(regions, spillfield, domain; usediags=true, \n                     return_region_reindex=false)\n\nUpdate a previously computed spillregion field inside a limited domain (where the spillfield has presumably changed).\n\nArguments\n\nregions::Matrix{Int}        : the previously computed spillregion field\nspillfield::Matrix{Int8}    : the locally updated spill field\ndomain::Domain2D            : domain within which the spillfield has changed,                                  and thus regions need to be updated\nusediags{Bool}              : if true, diagonal connections between cells                                  will also be considered\n`returnregionreindex{Bool}' : compute and return correspondence between old                                  and new region indices as a 2-column matrix,                                  first column represents old region numbers and                                  second column the new ones.  Note that there                                  may be both one-to-one, one-to-many and                                 many-to-one correspondences.\n\nSee also spillregions.\n\n\n\n\n\n","category":"method"},{"location":"static/#Spillpoints","page":"Static analysis","title":"Spillpoints","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The Spillpoint struct contains the information for a particular spill point, i.e. the point where a trap/lake spills over.  Spillpoint contains the index of the downstream region, the location of the spillpoint itself, as well as its vertical elevation.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The spillpoints function is used to compute all the spillpoints associated with a set of spill regions (which has been previously computed using spillregions).","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"spillpoints.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.Spillpoint","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.Spillpoint","text":"struct Spillpoint\n\nA struct representing the spillpoint of a trap.  It has the following fields:\n\ndownstream_region::Int: index of the downstream region.\ncurrent_region_cell::Int: index of the cell in the current region bordering on                              the spillpoint\ndownstream_region_cell::Int: index of the cell in the downstream region                                 bordering on the spillpoint\nelevation::Real: the elevation (vertical height) of the spillpoint\n\n\n\n\n\n","category":"type"},{"location":"static/#SurfaceWaterIntegratedModeling.Spillpoint-Tuple{}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.Spillpoint","text":"Default constructor of a Spillpoint instance sets all indices to zero and elevation to infinity.\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.spillpoints-Tuple{Matrix{<:Real}, Matrix{Int64}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.spillpoints","text":"spillpoints(grid, spillregions, usediags)\n\nCompute the spillpoint positions for each (low-level) spill region in the grid.\n\nAlso computes the topology of the lowest-level spill network (the graph describing the upstream/downstream relationship between spill regions).\n\nReturns a vector of Spillpoint with one entry per spill region (numbered from 1 upwards.  Each Spillpoint contains information on downstream spill region index, cell indices for the cell in the current region and downstream region that border on the spill point, and the heigh volume of the spill point.\n\nIn addition, returns a vector of 'boundaries', one per spill point.  The boundary for  spill region 'i' is defined by all the cell pairs (i, j) such that cell 'i', and 'j'  are neighbors, cell 'i' is in spill region 'i', and cell 'j' is in a different spill region 'j'.\n\nArguments\n\ngrid::Matrix{<:Real} - the terrain grid (matrix) with height values\nspillregions::Matrix{Int}: the matrix containing the regions already computed                                from the spillregions function\nusediags::Bool : if true (default), diagonal connections between cells will also be                    considered\ntiling::Union{Tuple{Int, Int}, Nothing}:        tuple specifying number of 'tiles' to subdivide surface in for parallel       processing.  Default is (1,1), which means the whole surface is treated       as a single tile (no parallel processing).\n\nSee also Spillpoint.\n\n\n\n\n\n","category":"method"},{"location":"static/#Subtrap-supertrap-hierarchy","page":"Static analysis","title":"Subtrap-supertrap hierarchy","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The sshierarchy! identifies higher-level traps from a set of subtraps. In other words, it identifies those traps that emerges when smaller traps coalesce as they fill up.  It requires the output of spillregions and spillpoints as part of it input.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"sshierarchy.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.sshierarchy!-Tuple{Matrix{<:Real}, Matrix{Int64}, Vector, Vector{Vector{Tuple{Int64, Int64}}}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.sshierarchy!","text":"sshierarchy!(grid, spillregions, spillpoints, boundaries)\n\nIdentify higher-level traps and spillpoints, resulting from merger of lower-level traps that flow into each other.\n\nThe vector of spillpoints, and the associated spillregion boundaries will be updated with the higher-level spillpoints and traps.\n\nThe arguments grid and spillregions will remain unmodified.\n\nThe function also returns a graph representing the hierarchy of subtraps and supertraps, and a vector listing the indices of the lowest-level spillregions contained within each trap.  For lowest-level traps, this list only references the trap itself, whereas for higher-level traps, it references all the low-level traps whose merger leads to the higher-level trap.\n\nArguments\n\ngrid::Matrix{<:Real}: terrain raster grid with height values.  This                         input argument remains unmodified.\nspillregions::Matrix{Int}: the matrix containing the lowest-level                               regions, already computed from the                               spillregions function.  This                              input argument remains unmodified.\nspillpoints::Vector{Spillpoint}: vector of lowest-level spillpoints                                    (corresponding to the lowest-level                                     regions), as computed by the                                     spillpoints function.                                      This vector will be modified, as it                                     will be supplemented with the newly                                    identified, higher-level spillpoints.\nboundaries::Vector{Vector{Tuple{Int, Int}}}:            vector containing the boundaries for each of the lowest-level spill           regions.  This vector will be modified, as it will be extended           with the boundaries of the newly found higher-level spill regions.           Each boundary is represented by a vector of integer pairs, where            each integer pair are the indices of two neighbor cells in the grid;           one on each side of the region boundary.\n\n\n\n\n\n","category":"method"},{"location":"static/#Trap-volumes","page":"Static analysis","title":"Trap volumes","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The function [trapvolumes][@ref] is used to compute the volumes of all traps and subtraps identified on an analysed surface. It requires the result of  spillregions and spillpoints as input parameters.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"trapvolumes.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.trapvolumes-Tuple{Matrix{<:Real}, Matrix{Int64}, Vector{Spillpoint}, Vector{Vector{Int64}}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.trapvolumes","text":"trapvolumes(grid, spillregions, spillpoints, lowest_regions)\n\nCompute the volume of all traps (at all levels) identified for a topography grid.\n\nThe necessary input to this function can be provided by spillregions,  spillpoints and sshierarchy!.  The result is returned in form of a vector of floating point numbers, with one entry per trap, giving the volume  of that trap.\n\nArguments\n\n- `grid::Matrix{<:Real}`: the topographical grid that has been analysed \n- `spillregions::Matrix{Int}`: of same size as `grid`, where the integer at entry\n                               (i, j) gives the region number of cell (i, j) in `grid`.\n- `spillpoints::Vector{Spillpoint}`: vector with the identified spillpoints, as\n                                     provided by the [`spillpoints`](@ref) function.\n                                     There is one spillpoint per trap.\n- `lowest_regions::Vector{Vector{Int}}`: each entry in this vector corresponds to \n                                         a trap, and list all the low-level regions\n                                         that combined constitute the spill region\n                                         of this trap.\n\nSee also spillregions, spillpoints and sshierarchy!.  \n\n\n\n\n\n","category":"method"},{"location":"static/#Domain","page":"Static analysis","title":"Domain","text":"","category":"section"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"The Domain2D struct represent a rectangular subpart of a terrain grid.  It is mainly used to specify subsets of a terrain that should be updated or processed in parallel.","category":"page"},{"location":"static/","page":"Static analysis","title":"Static analysis","text":"Modules=[SurfaceWaterIntegratedModeling]\nPages = [\"domain.jl\"]","category":"page"},{"location":"static/#SurfaceWaterIntegratedModeling.Domain2D","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.Domain2D","text":"struct Domain2D\n\nType representing a Cartesian (sub)domain of a grid, defined by all gridcells indexed (ix, iy) such that ix ∈ xrange and iy ∈ yrange.\n\nFields\n\nxrange::UnitRange{Int}: range of domain in the first coordinate direction\nyrange::UnitRange{Int}: range of domain in the second coordinate direction\n\n\n\n\n\n","category":"type"},{"location":"static/#Base.max-Tuple{Domain2D, Int64}","page":"Static analysis","title":"Base.max","text":"max(d::Domain2D, dir::Int)\n\nReturn maximum value of 2D domain d, in first or second direction\n\n\n\n\n\n","category":"method"},{"location":"static/#Base.min-Tuple{Domain2D, Int64}","page":"Static analysis","title":"Base.min","text":"min(d::Domain2D, dir::Int)\n\nReturn minimum value of 2D domain d, in first or second direction\n\n\n\n\n\n","category":"method"},{"location":"static/#Base.size-Tuple{Domain2D}","page":"Static analysis","title":"Base.size","text":"size(d::Domain2D)\n\nReturn size of 2D domain d\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.tiledomain-Tuple{Domain2D, Any, Any}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.tiledomain","text":"tiledomain(dom, tilenum_x, tilenum_y)\n\nDivide a given domain up into a cartesian grid of subdomains ('tiles')\n\nThe domain 'dom' is split up into a grid of domains, with 'tilenum_x' number of domain in the first coordinate direction, and 'tilenum_y number of domains in the second.  \n\nReturns a Vector{Domain2D} with all the resulting subdomains.  A second return argument gives a tuple of integer vectors specifying where the splits happened in the first and second coordinate directions.\n\nSee also Domain2D\n\n\n\n\n\n","category":"method"},{"location":"static/#SurfaceWaterIntegratedModeling.tiles-Tuple{Vector{Int64}, Vector{Int64}}","page":"Static analysis","title":"SurfaceWaterIntegratedModeling.tiles","text":"tiles(xsplit::Vector{Int}, ysplit::Vector{Int})\n\nDivide a domain up into a cartesian grid of subdomains ('tiles')\n\nThe vectors xsplit and ysplit should be monotonously increasing integer vectors that specify where to split an underlying 2D region into subdomains.\n\nThe function will return a vector of Domain2D that tile the  domain.  If xsplit is of length Nx and ysplit of length Ny, the number of tiles generated will be (Nx-1) x (Ny-1).\n\n\n\n\n\n","category":"method"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"EditURL = \"../../examples/flat_areas.jl\"","category":"page"},{"location":"flat_areas/#Handling-flat-areas","page":"Handling flat areas","title":"Handling flat areas","text":"","category":"section"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"This is a simple demonstration of how large flat surfaces (like large water bodies) can be recognized, and straightened or excluded from analysis if desired [1].","category":"page"},{"location":"flat_areas/#Imporing-packages-and-loading-the-surface.","page":"Handling flat areas","title":"Imporing packages and loading the surface.","text":"","category":"section"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"using SurfaceWaterIntegratedModeling\nimport CairoMakie, Images # for visualization and loading of textures\nimport ColorSchemes\nusing Pkg.Artifacts","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"The package with SWIM testdata is provided as a Julia artifact, which can be accessed using the function datapath_testdata.  We subsequently load and display the synthetic grid.","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"datapath = joinpath(datapath_testdata(), \"data\", \"small\")\ngrid = loadgrid(joinpath(datapath, \"bay.txt\"));\n\n# for ease of use, we create our own label of key colors found in the\n# colorsheme `:Paired_12` used below\ncmap = Dict(:blue => 2, :green => 4, :red => 6, :orange => 8,\n            :lilac => 10, :bright => 11);\n\n# Also define a preset viewpoint\nview1 = (CairoMakie.Vec(1059, 783, 622), CairoMakie.Vec(280, 311, 58), 0.68);\nnothing #hide","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"The terrain used for demonstration is a varied surface that includes hills, a mountainside, a road, and ocean areas.","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"tex = fill(cmap[:green], size(grid))\nsf, fig, sc = plotgrid(grid, texture = tex,\n                       colormap=ColorSchemes.:Paired_12,\n                       colorrange=(1,12))\nset_camerapos(sc, view1...)","category":"page"},{"location":"flat_areas/#Identifying-flat-areas-and-running-spill-analysis","page":"Handling flat areas","title":"Identifying flat areas and running spill analysis","text":"","category":"section"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"While the ocean part is clearly visible on the surface, its cells in the terrain grid have not been identified.  For this purpose, the identify_flat_areas function can be used:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"rel_tol = 1e-3 # relative tolerance for an angle between two cells to be considered zero\nmax_cluster_size = 1 # threshold for excluding too small areas\nisflat = identify_flat_areas(grid, rel_tol, max_cluster_size)\n\ntex[isflat] .= cmap[:blue]\ndrape_surface(sf, tex)\nset_camerapos(sc, view1...)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"We can see that the ocean part was correctly identified as flat, but so were many parts that ought not be included.  We can increase the cluster size limit to filter these parts out.","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"max_cluster_size=100\nisflat = identify_flat_areas(grid, rel_tol, max_cluster_size)\n\ntex[isflat] .= cmap[:blue]\ntex[.!isflat] .= cmap[:green]\ndrape_surface(sf, tex)\nset_camerapos(sc, view1...)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"With this value for the threshold, only the ocean remains identified as flat.","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"For the surface used in this example, the ocean surface is already exactly flat.  However, it is sometimes the case with terrain input data that conceptually flat regions still contains small irregularities that may cause noisy output from the spill analysis.  One way to handle this, is to use the flatten_grid! function, which ensures that flat parts are exactly that.  Even if not strictly necessary for our sample terrain, we demonstrate the use below:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"flatten_grid!(grid, isflat, :min)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"Another way to exclude flat areas from the analysis is to declare them as \"sinks\".  For oceans, this makes conceptual sense, since they can be considered traps with \"infinite\" capacity.  For other large flat areas, e.g. parking lots, this approach does not work so well, and flatten_grid! should be used.  For our terrain, declaring the flat areas as sinks should be fine.  We pass along isflat as the sink map in our call to spillanalysis below:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"tstruct = spillanalysis(grid, sinks=isflat)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"The spill anaysis was able to identify 895 spill regions and 1118 traps:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"print(\"Number of spill regions identified: \", numregions(tstruct), '\\n')\nprint(\"Number of traps identified: \", numtraps(tstruct), '\\n')","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"We can visualize the traps, spill regions, rivers and oceans on the terrain surface by creating a texture with show_region_selection:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"tex = show_region_selection(tstruct,\n                            region_color=cmap[:green],\n                            river_color=cmap[:blue]-1,\n                            trap_color=cmap[:blue]);\nnothing #hide","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"Terrain that spills directly to the ocean, or out of the domain is assigned a light green color, to distinguish it from terrain that spills to identified traps, while the ocean is set to blue:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"tex[tex.==0] .= cmap[:green]-1;\ntex[isflat] .= cmap[:blue];\n\ndrape_surface(sf, tex)\nset_camerapos(sc, view1...)","category":"page"},{"location":"flat_areas/#Adding-more-sinks","page":"Handling flat areas","title":"Adding more sinks","text":"","category":"section"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"The ridge in front of the large lake in the upper left part of the plot is actually a railroad.  The regions immediately in front of it and behind it should be considered drained, so water does not massively accumulated like the above plot indicates.  By adding a drain near its lowest point, the lake goes away:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"sinks = [(119,193), (180, 193)]; # two drain locations\nfor s in sinks\n    # add the sinks to the map that we used to represent sinks (and flat areas)\n    isflat[s...] = true;\nend\n\n# run the spill analysis again\ntstruct = spillanalysis(grid, sinks=isflat)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"The result of this analysis no longer indicate a large lake in this region:","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"tex = show_region_selection(tstruct,\n                            region_color=4,\n                            river_color=2,\n                            trap_color=2);\ntex[tex.==0] .= cmap[:green]-1\ntex[isflat] .= cmap[:blue]\n\ndrape_surface(sf, tex)\nset_camerapos(sc, view1...)","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"[1]: The data used in this example was originally obtained from Kartverket (the Norwegian Mapping Authority) under the Creative Commons Attribution 4.0 International (CC BY 4.0) license.","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"","category":"page"},{"location":"flat_areas/","page":"Handling flat areas","title":"Handling flat areas","text":"This page was generated using Literate.jl.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"EditURL = \"../../examples/synthetic.jl\"","category":"page"},{"location":"synthetic/#Simple-synthetic-example","page":"Simple synthetic example","title":"Simple synthetic example","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The purpose of this example is to introduce some key concepts of SWIM by demonstration on an extremely simple synthetic terrain grid.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The synthetic terrain contains three low-level traps ('ponds', 'lakes'), and one higher-level trap.  Its topological structure is shown in Fig. 1 below.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"On this diagram we see that trap 1 and 2 are subtraps of trap 4, i.e. they are smaller traps contained within the footprint of trap 4.  When trap 4 is filled with water and spills over, the water will flow downwards into downstream trap 3.  When trap 3 is filled, the water will spill out of the surface domain.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The details of this will be made cleared below, as we demonstrate the concepts on the synthetic surface.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"(Image: image) Fig. 1: Topological structure of the traps in the synthetic surface","category":"page"},{"location":"synthetic/#Importing-packages-and-loading-the-surface","page":"Simple synthetic example","title":"Importing packages and loading the surface","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"using SurfaceWaterIntegratedModeling\nimport CairoMakie, Images # for visualization and loading of textures\nimport ColorSchemes\nimport Graphs\nusing Pkg.Artifacts","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The package with SWIM testdata is provided as a Julia artifact, which can be accessed using the function datapath_testdata.  We subsequently load and display the synthetic grid.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"datapath = joinpath(datapath_testdata(), \"data\", \"synthetic\")\ngrid = loadgrid(joinpath(datapath, \"synsurf.txt\"))\n\n# for ease of use, we create our own label of key colors found in the\n# colorsheme `:Paired_12` used below\ncmap = Dict(:blue => 2, :green => 4, :red => 6, :orange => 8,\n            :lilac => 10, :bright => 11)\n\n# We also define some view angles that will come in handy\nview1 = (CairoMakie.Vec(-83, 378, 197), CairoMakie.Vec(100, 114, -4.5), 0.68)\nview2 = (CairoMakie.Vec(90, 494, 8.6), CairoMakie.Vec(100, 114, -4.5), 0.68);\n\n# plot the grid\nsf, fig, sc = plotgrid(grid, texture=fill(cmap[:bright], size(grid)),\n                       colormap=ColorSchemes.:Paired_12,\n                       colorrange=(1, 12), wireframe=true)\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Grid seen from above.  Trap 1 and 2 from Fig. 1 can be seen on the upper left side, wheras trap 3 is seen downstream on the lower right side.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"set_camerapos(sc, view2...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Grid seen from the side.  Here we see how trap 1 and 2 (right) constitute subtraps, or pockets, within a larger trap 4.  As they gradually fill with water, two separate ponds for trap 1 and 2 will coalesce into a single pond for trap 4.  We refer to trap 1, 2 and 3 as \"lowest-level traps\", i.e. traps that do not have subtraps.  Trap number 4 is not a lowest-level trap, since it has trap 1 and 2 as subtraps.","category":"page"},{"location":"synthetic/#Identifying-traps,-subtraps-and-spill-path","page":"Simple synthetic example","title":"Identifying traps, subtraps and spill path","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The traps, spillregions (watersheds) and their topological structure is computed by the spillanalysis function.  The result is stored in a TrapStructure.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct = spillanalysis(grid);\nnothing #hide","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The numtraps function show the number of traps identified:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"numtraps(tstruct)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"This number includes all traps, whether they are lowest-level or not.","category":"page"},{"location":"synthetic/#Examining-the-trap-structure","page":"Simple synthetic example","title":"Examining the trap structure","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The returned TrapStructure has the following fields:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"[fieldnames(typeof(tstruct))...]","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We will go through and explain these fields below.","category":"page"},{"location":"synthetic/#Traps-and-trap-regions","page":"Simple synthetic example","title":"Traps and trap regions","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The :footprints field contains the footprint of all traps, i.e. all cells that are covered by each trap's extent.  In the below code, we assign different colors to each trap, and plot them on the grid.  Note that since the footprints of trap 1 and 2 are contained inside trap 4, we overwrite the footprint of trap 4 with the footprints of trap 1 and 2 in the code below so that they are all seen on the same figure.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"# We generate a texture to drape the surface with, and color the cells within\n# trap footprints in different colors.\ntex = fill(cmap[:bright], size(grid))\ntex[tstruct.footprints[4]] .= cmap[:orange]\ntex[tstruct.footprints[1]] .= cmap[:red]\ntex[tstruct.footprints[2]] .= cmap[:green]\ntex[tstruct.footprints[3]] .= cmap[:blue]\n\ndrape_surface(sf, tex);\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Trap 1 and 2 are shown in red and green respectively, trap 3 in blue and trap 4 in orange.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Each of these traps have an associated watershed, or spill region.  All water landing in a given watershed, will eventually reach and accumulate in the associated trap.  The :regions field gives the spill regions for the lowest-level traps.  (For a trap with subtraps, its spill region is the union of the spill regions of its subtraps).","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The number of regions is therefore equal to the number of lowest-level traps. We can query this number with the numregions function:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"numregions(tstruct)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"As we can see, there are three spill regions in the grid, associated with lowest-level traps 1, 2 and 3.  We here visualize these alongside the traps","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex = fill(cmap[:bright], size(grid))\n# Indicate the spill regions\ntex[tstruct.regions .== 1] .= cmap[:red]-1\ntex[tstruct.regions .== 2] .= cmap[:green]-1\ntex[tstruct.regions .== 3] .= cmap[:blue]-1\n# Indicate the associated  traps\ntex[tstruct.footprints[1]] .= cmap[:red]\ntex[tstruct.footprints[2]] .= cmap[:green]\ntex[tstruct.footprints[3]] .= cmap[:blue]\n\ndrape_surface(sf, tex);\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The spill region of trap 4 is the union of the blue and green regions on this plot.  The beige-colored part of the surface does not spill to any trap; water landing in this region will flow out of the surface domain.","category":"page"},{"location":"synthetic/#Spill-field","page":"Simple synthetic example","title":"Spill field","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The :spillfield field expressed the local direction of flow over the surface.  For a given cell, the flow will be directed towards its neighbor cell along the steepest local slope.  There are four or eight such neighbor cells, depending on whether one count the cells connected across diagonals (specified by the usediags argument when calling spillanalysis). We can visualize the spillfield by draping it directly on the surface:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tstruct.spillfield .*2)\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The eight different colors on this plot indicate the eight different local flow directions.  The bright blue color, which makes up most of the grid's surface, correspond to a flow directed towards the lower edge of the grid.","category":"page"},{"location":"synthetic/#Spillpoints","page":"Simple synthetic example","title":"Spillpoints","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"A trap's spillpoint is the point at which it will overflow when filled up. Information about spillpoints is found in the :spillpoints field of the TrapStructure.  Let us inspect the content of the spillpoint of trap 1:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct.spillpoints[1]","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"[fieldnames(typeof(tstruct.spillpoints[1]))...]","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The :downstream_region field gives the region that the spillpoint leads into (2 in this case, since trap 1 spills into trap 2).  The :current_region_cell and downstream_region_cell fields indicate the corresponding two cells adjacent to the spillpoint.  The :elevation field provides the grid terrain value at the spillpoint.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We now plot all the spillpoints along with the traps and spill regions below:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"for sp in tstruct.spillpoints\n    tex[sp.current_region_cell] = cmap[:orange]\n    tex[sp.downstream_region_cell] = cmap[:lilac]\nend\ndrape_surface(sf, tex);\nset_camerapos(sc,\n              CairoMakie.Vec(49.3, 156.7, 90.7), # set observer position\n              CairoMakie.Vec(86.8, 100.7, -3.3), # set observer target point\n              0.95) # zoom level","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Note that trap 1 and 2 spill into each other.  This is always the case with subtraps.  Once both are filled, they will coalesce and water will start filling the rest of the supertrap (trap 4 in this case) until that trap's spillpoint is reached.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We can also visualize the \"river\" flowing from one spillpoint to the next, using the show_region_selection function, which we here apply to trap 3 and 4:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex = show_region_selection(tstruct, selection=[3, 4],\n                            region_color=cmap[:green]-1, trap_color=cmap[:green],\n                            river_color=cmap[:red])\ndrape_surface(sf, tex);\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Here, we can see how trap 4 spills into trap 3, and trap 3 spills out of the domain.","category":"page"},{"location":"synthetic/#Trap-volumes-and-subvolumes","page":"Simple synthetic example","title":"Trap volumes and subvolumes","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The field :trapvolumes refers to the amount a water can hold when it is full:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct.trapvolumes","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We here see that the largest trap is 4, which is unsurprising as it subsumes trap 1 and 2.  The :subvolumes field refers to the amount of water a trap's subtraps can hold:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct.subvolumes","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Here, we see that the only trap with nonzero subvolumes is trap 4 (the other ones being lowest-level traps).","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"# Verify that the subvolume equals the sum of its subtrap volumes\ntstruct.subvolumes[4] - (tstruct.trapvolumes[1] + tstruct.trapvolumes[2])","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"# The volume of trap 4 that is *not* covered by its subtraps:\ntstruct.trapvolumes[4] - tstruct.subvolumes[4]","category":"page"},{"location":"synthetic/#Hierarchy-of-subtraps-and-supertraps","page":"Simple synthetic example","title":"Hierarchy of subtraps and supertraps","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The field :lowest_subtraps_for lists all the lowest-level subtraps that are contained within a trap (note that a trap always includes itself):","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct.lowest_subtraps_for","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The field :supertraps_of lists all the supertraps of each lowest-level trap.  In nested trap hierarchies, there may be many supertraps for a given lowest-level trap (also note that a trap always includes itself):","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstruct.supertraps_of","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Trap 4 is not a lowest-level trap, and is therefore not included in the output here.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The subtrap/supertrap hierarchy constitutes a tree graph that is stored in the :agglomerations field and can be queried directly using the Graphs package:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"# Subtraps of trap 4\nGraphs.inneighbors(tstruct.agglomerations, 4)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"# Immediate supertrap of trap 1\nGraphs.outneighbors(tstruct.agglomerations, 1)","category":"page"},{"location":"synthetic/#Tracking-developments-over-time","page":"Simple synthetic example","title":"Tracking developments over time","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The fill_sequence function can be used to track developments over time. The result is a sequence of SpillEvents, which can be used to rapidly determine the flow and accumulation state across the terrain at any given moment.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We first demonstrate fill_sequence without infiltration and with a constant rain rate.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"weather = [WeatherEvent(0.0, 1.0)] # Rain with intensity 1.0 starting at time 0.0\nseq = fill_sequence(tstruct, weather);\nnothing #hide","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The element type of seq is SpillEvent.  We will not discuss its internal structure here. With the exception of :timestamp, its fields should not be accessed directly, but though the use of the following \"accessor\" functions:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"amount_at\nfilled_at\ninflow_at\nrunoff_at\nrainrate_at","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Refer to the documentation for more information on the SpillEvent and its accessor functions.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"for i = 1:length(seq)\n    print(\"Time: \", seq[i].timestamp, \", trap fill states: \", filled_at(seq, i), '\\n')\nend","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The printed info above shows the different points in time when a trap changes its state.  We see that trap 1 fills up at t=0.119, trap 2 at t=0.15, etc. (In this case, the traps happen to be filled in the same order as they are numbered, but this is not the general case).","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"For a given event, we can get information on the amount of water in each trap:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"amount_at(seq, 3) ## query the third event in the sequence","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The amount for each trap is given as a tuple of values; the first giving an amount of water, and the second the point in time where this amount was last computed.  Note that in this case, the amounts in trap 1 and 3 were last computed at an earlier point in time than the current timestamp (0.15067), and these values are therefore not immediately useful.  A trap only has its amount updated when an event cause a change to the traps inflow rate (e.g. upstream traps that fill up, or weather changes).  In order to get all the updated amounts, we can use the current inflow rates and time since last update:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"amounts = [e.amount for e ∈ amount_at(seq, 3)] ## amounts when last computed\ndt = seq[3].timestamp .- [e.time for e ∈ amount_at(seq, 3)] ## time since last update\namounts += dt .* inflow_at(seq, 3) # add inflow since last update","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The runoff across the terrain also depend on which events have occured.  We visualize the runoff at the last event (when all traps are filled):","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex = runoff_at(seq, 5)\nfilled_trapcells = vcat(tstruct.footprints[:]...) ## footprint of all cells\ntex[filled_trapcells] .= extrema(tex)[2] # maximum value\nsf_flow, fig_flow, sc_flow = plotgrid(grid, texture=tex, colormap=:Blues);\n\nset_camerapos(sc_flow, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The flow is strongly concentrated along the streams exiting from each trap, drowning out any other detail.  To make more details visible, we can use a logarithmic plot:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex = log10.(runoff_at(seq, 5))\ntex[filled_trapcells] .= extrema(tex)[2] # maximum value\nsf_flow_log, fig_flow_log,  sc_flow_log = plotgrid(grid, texture=tex, colormap=:Blues)\n\nset_camerapos(sc_flow_log, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Although the SpillEvents in seq describe the points in time where one or more trap statuses change, we may also be interested in the amount of water and flow state at some arbitrary point in time.  For this, we can use the functions trap_states_at_timepoints and interpolate_timeseries.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Let us first specify some \"arbitrary\" points in time:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tpoints = [0.1, 0.3, 0.42]","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We can now compute the water content in all traps at this timepoint as follows:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tstates = trap_states_at_timepoints(tstruct, seq, tpoints)\nwater_content = [e[2] for e in tstates]\nfor time_ix = 1:length(tpoints)\n    print(\"At time: \", tpoints[time_ix], \":\\n\")\n    for trap_ix = 1:4\n        content = water_content[time_ix][trap_ix]\n        subtraps = Graphs.inneighbors(tstruct.agglomerations, trap_ix)\n        for i in subtraps\n            # add in water from subtraps\n            content += water_content[time_ix][i]\n        end\n        print(\"   Trap: \", trap_ix, \" contains: \", content, \" units of water.\\n\")\n    end\nend","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Note here that the volumes returned by trap_states_at_timepoints excludes the water in subtraps, so these have to be added in the loop above.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We can also visualize the trap fill states using interpolate_timeseries.  We here generate textures where the filled parts of traps are shown in blue, the dry parts in orange, and active streams in red:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex, = interpolate_timeseries(tstruct, seq, tpoints,\n                              filled_color=cmap[:blue],\n                              trap_color=cmap[:orange],\n                              river_color=cmap[:red])\n\ndrape_surface(sf, tex[1])\n\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.1","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[2])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.3","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[3])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.42","category":"page"},{"location":"synthetic/#Infiltration","page":"Simple synthetic example","title":"Infiltration","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The speed and degree to which traps get filled will strongly depend on the permeability of the surface. SWIM provides a simplified infiltration model with a fixed infiltration rate, which may be an acceptable approximation over limited timespans.  The way of doing this is to define an infiltration map, and pass it along to fill_sequence.  The steps are shown below:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"First we define an infiltration map, prescribing an infiltration rate at every cell in the grid.  We here define an infiltration rate that is 0 (impermeable) at the upper part of the grid, and 2.0 at the lower part:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"infil = fill(0.0, size(grid));\ninfil[1:110, 1:end] .= 2.0;\nsf_infil, fig_infil, sc_infil = plotgrid(grid, texture=infil,\n                                         colormap=ColorSchemes.:rainbow,\n                                         colorrange=(0, 2))\n\nset_camerapos(sc_infil, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"In this figure, the purple part of the surface is impermeable, and the red part has an infiltration rate value of 2.0.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Note that the infiltration rate is here set to be higher than the precipitation rate given by weather.  As such, the only way the lower trap can fill up is by receiving runoff from the impermeable part of the grid.  This will significantly delay the moment when it gets filled.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"seq2 = fill_sequence(tstruct, weather, infiltration=infil)\n\nfor i = 1:length(seq2)\n    print(\"Time: \", seq2[i].timestamp, \", trap fill states: \", filled_at(seq2, i), '\\n')\nend","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We see that the order in which the traps fill up is now different than in the case without infiltration.  The time for trap 3 to fill up is significantly longer.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We inspect the trap states at the same timepoints as in the impermeable case above. In addition, we include an additional timepoint at t=0.60.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tpoints2 = [0.1, 0.3, 0.42, 0.60]\ntex, = interpolate_timeseries(tstruct, seq2, tpoints2,\n                              filled_color=cmap[:blue],\n                              trap_color=cmap[:orange],\n                              river_color=cmap[:red])\ndrape_surface(sf, tex[1])\n\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.1","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[2])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.3","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[3])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.42","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[4])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.60","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"Here, we can see that trap 3 does not start to fill up before trap 4 starts spilling over.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"To better understand what is going on, we can inspect the flow pattern at the time of the last event:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"runoff = runoff_at(seq2);\nnothing #hide","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The runoff field is defined such that positive values represent overland flow intensity, whereas negative values represent remaining infiltration capacity. First, we are interested in the part of the terrain that remains dry, i.e. local infiltration exceeds the combined value of precipitation and inflow from upstream:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"dry_terrain = Float64.(runoff .< 0.0)\ndry_terrain[filled_trapcells] .= false ## submerged terrain should be considered wet\n                                       # regardless of inflow and infiltration rates\ndrape_surface(sf_infil, dry_terrain)\n\nset_camerapos(sc_infil, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"From this figure, where dry terrain is shown in green, the following observations can be noted:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"The terrain surrounding trap 3 is dry, and its only inflow comes from the stream spilling out from trap 4.\nLarge part of the terrain is wet even where infiltration rates exceed precipitation rate, due to upstream runoff.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"We can use a log plot to visualise the flow pattern on the wet part of the surface:","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tex_flow = log10.(max.(runoff, eps()))\ntex_flow[runoff .< 0.0] .= minimum(tex_flow[:])\ntex_flow[filled_trapcells] .= maximum(tex_flow[:])\ndrape_surface(sf_flow_log, tex_flow)\n\nset_camerapos(sc_flow_log, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"One interesting thing to note from this plot is how overland flow builds up across the impermeable part of the surface, and then gradually attenuates as the flow reaches the permeable region.","category":"page"},{"location":"synthetic/#Changing-weather","page":"Simple synthetic example","title":"Changing weather","text":"","category":"section"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"It is possible to model a changing weather by sending multiple weather events to the fill_sequence function.  As a demonstration, we extend our weather vector with another event, stating that the rain rate drops to zero at time 0.8.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"weather = [WeatherEvent(0.0, 1.0),\n           WeatherEvent(0.8, 0.0)]\nseq3 = fill_sequence(tstruct, weather, infiltration=infil);\nnothing #hide","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"In the time before the weather change, the sequence is similar to the previous one we inspected above.  We add new timepoints at t=0.8 (when rain ceases), and t=2.1 (well after rain has stopped).","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"tpoints3 = [0.3, 0.60, 0.8, 2.1]\ntex, = interpolate_timeseries(tstruct, seq3, tpoints3,\n                              filled_color=cmap[:blue],\n                              trap_color=cmap[:orange],\n                              river_color=cmap[:red])\n\ndrape_surface(sf, tex[1])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.3.  This is identical to the previous case above.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[2])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.6.  This is also identical to the previous case above.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[3])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 0.8.  This is when rain stops.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"drape_surface(sf, tex[4])\nset_camerapos(sc, view1...)","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"At time 2.1. We note that the water level in trap 4 on the impermeable part of the terrain remains unchanged, whereas the water level in trap 3, on the permeable part of the domain, has dropped significantly.","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"","category":"page"},{"location":"synthetic/","page":"Simple synthetic example","title":"Simple synthetic example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"EditURL = \"../../examples/urban.jl\"","category":"page"},{"location":"urban/#Urban-landscape","page":"Urban landscape","title":"Urban landscape","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"This example demonstrates the application of static and dynamic functionality in SWIM in an urban setting using real data.  The example is from the 'Kuba' area in central Oslo.  The topography with some steep hills and a high degree of impermeable surfaces makes the area sensitive to intense rainfall events.","category":"page"},{"location":"urban/#Loading-the-necessary-packages","page":"Urban landscape","title":"Loading the necessary packages","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"using SurfaceWaterIntegratedModeling\nimport CairoMakie, Images # for visualization and loading of textures\nimport ColorSchemes\nusing Pkg.Artifacts\nimport ArchGDAL # for loading of topographical grids from files in geotiff format","category":"page"},{"location":"urban/#Prepare-data","page":"Urban landscape","title":"Prepare data","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The package with SWIM testdata is provided as a Julia artifact, which can be accessed using the function datapath_testdata.  We subsequently load a digital surface model (including buildings and vegetation) and a digtial terrain model (without buildings or vegetation) of the area of study [1]. The data is converted into simple Julia arrays with height values stored as Float64.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"kuba_datapath = joinpath(datapath_testdata(), \"data\", \"kuba\")\ngeoarray_dsm = ArchGDAL.readraster(joinpath(kuba_datapath, \"dom1\", \"data\", \"dom1.tif\"))\ngeoarray_dtm = ArchGDAL.readraster(joinpath(kuba_datapath, \"dtm1\", \"data\", \"dtm1.tif\"))\n\ngrid_dtm = permutedims(geoarray_dtm[:,:,1]) .|> Float64\ngrid_dsm = permutedims(geoarray_dsm[:,:,1]) .|> Float64\ntypeof(grid_dtm), size(grid_dtm)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"In addition to the elevation data, we also load a set of textures and masks that can be used to visualize the model, as well as indicate the locations of buildings, permeable areas, rivers and sinks (e.g. manholes).","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"mapimg = Images.load(joinpath(kuba_datapath, \"textures\", \"kuba.png\"))\nphotoimg = Images.load(joinpath(kuba_datapath, \"textures\", \"kuba_photo.png\"))\n\nbuilding_mask = Images.load(joinpath(kuba_datapath, \"textures\", \"building_mask.png\"))\npavement_mask = Images.load(joinpath(kuba_datapath, \"textures\", \"pavement_mask.png\"))\nriver_mask = Images.load(joinpath(kuba_datapath, \"textures\", \"river_mask.png\"))\npermeable_mask = Images.load(joinpath(kuba_datapath, \"textures\", \"permeable_mask.png\"))\nsink_mask = Images.load(joinpath(kuba_datapath, \"textures\", \"sink_mask.png\"))\ntypeof(sink_mask), size(sink_mask)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The textures are not all of the same resolution.  We resize them all to equal resolution; twice the topographical grid resolution in both directions.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"mapimg = Images.imresize(mapimg, size(grid_dtm) .* 2)\nphotoimg = Images.imresize(photoimg, size(mapimg))\n\nbuilding_mask = Images.imresize(building_mask, size(mapimg))\npavement_mask = Images.imresize(pavement_mask, size(mapimg))\nriver_mask = Images.imresize(river_mask, size(mapimg))\npermeable_mask = Images.imresize(permeable_mask, size(mapimg))\nsink_mask = Images.imresize(sink_mask, size(mapimg))\nsize(sink_mask)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"We can visualize the model surfaces with the textures to see how the area looks. Here, we show the terrain model with the map texture and the surface model with the aerial photo texture.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"sfmap, figmap, scmap = plotgrid(grid_dtm, texture=mapimg)\nsfpho, figpho, scpho = plotgrid(grid_dsm, texture=photoimg)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The plotgrid function creates a 3D scene.  If GLMakie is used, the scene is displayed in a graphical window that can be navigated using the keyboard and mouse.  The viewpoint of the scene can also be changed programatically using set_camerapos. We predefine a couple of viewpoints on the form (camera position, target, zoomlevel):","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"view1 = (CairoMakie.Vec(1223, 587, 1056), CairoMakie.Vec(391, 327, 13.8), 0.66);\nview2 = (CairoMakie.Vec(1223, 587, 1056), CairoMakie.Vec(391, 327, 13.8), 0.30);\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Here is a snapshot for the terrain model:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(scmap, view1...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"And a snapshot of the surface model:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(scpho, view1...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Here is a visualization of the different masks loaded:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"fig = CairoMakie.Figure()\nmaskarray = [building_mask, pavement_mask, river_mask, permeable_mask, sink_mask]\nmasktitles= [\"Building mask\", \"Pavement mask\", \"River mask\", \"Permeable mask\", \"Sink mask\"]\nfig_axes = []\nfor i = 1:5\n    push!(fig_axes, CairoMakie.Axis(fig[Int(ceil(i/3)), mod(i-1, 3)+1]))\n    CairoMakie.image!(fig_axes[end], rotr90(maskarray[i]))\n    fig_axes[end].title = masktitles[i]\nend\nfig_yres = Int(ceil(size(building_mask, 2) / 3))\nCairoMakie.resize!(fig.scene, fig_yres * 3, fig_yres * 2)\nfig","category":"page"},{"location":"urban/#Prepare-and-run-the-static-analysis","page":"Urban landscape","title":"Prepare and run the static analysis","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"In this step, we run a static analysis on the terrain, to determine the following information:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The flow pattern of water on the terrain, i.e. how water moves from one grid-cell to the next, assuming infinitesimal, gravity-driven flow.\nIdentify accumulation regions (lakes), and two related tree-like hierarchies:\nHow separate lakes merge as they grow (subtraps -> supertraps)\nHow lakes, once full, pour into lakes further downstream (upstream traps -> downstream traps)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"We run the analysis twice.  In the first run we only consider the impact of buildings, in the second we also include sinks in the analysis.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The spillanalysis function requires that overlay masks indicating buildings or sinks have the same resolution as the topographical grid.  We therefore resize building- and sink masks below.  Note that in the input data, sinks are often represented as a single pixel, so they risk disappearing in the downsampling process.  To prevent this, we downsample the grids as full grayscale images, and then quantify to a logical mask where all completely black pixels are set to false and all other pixels set to true.","category":"page"},{"location":"urban/#Downsampling-the-building-and-sink-masks","page":"Urban landscape","title":"Downsampling the building and sink masks","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"(The river is also treated as a sink here).","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"bmask = Images.imresize(building_mask, size(grid_dtm))\nbmask[bmask .!= Images.Gray{Images.N0f8}(0.0)] .= Images.Gray{Images.N0f8}(1.0)\nbmask = Matrix{Bool}(bmask .== Images.Gray{Images.N0f8}(1.0))\n\nsmask = Images.imresize(sink_mask + river_mask, size(grid_dtm))\nsmask[smask .!= Images.Gray{Images.N0f8}(0.0)] .= Images.Gray{Images.N0f8}(1.0)\nsmask = Matrix{Bool}(smask .== Images.Gray{Images.N0f8}(1.0));\nnothing #hide","category":"page"},{"location":"urban/#Run-the-two-spill-analyses","page":"Urban landscape","title":"Run the two spill analyses","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"tstruct_nosinks = spillanalysis(grid_dtm, building_mask=bmask)\ntstruct_sinks = spillanalysis(grid_dtm, building_mask=bmask, sinks=smask);\n\n# Visualize the result of the static analyses","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"To visualize the result, we will map the identified lakes and their connections on top of the topography surface.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"First, we need to define the colors used for indicating buildings and lakes. We then generate a grid indicating the presence of buildings, traps or rivers, and upsample it to match the resolution of the map/photo textures.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"white_color = eltype(mapimg)(1.0, 1.0, 1.0)\nblue_color = eltype(mapimg)(0.0, 0.0, 1.0)\nred_color = eltype(mapimg)(1.0, 0.0, 0.0)\ngreen_color = eltype(mapimg)(0.0, 1.0, 0.0)\nblack_color = eltype(mapimg)(0.0, 0.0, 0.0)\nbeige_color = Images.RGBA{Images.N0f8}(0.933, 0.867, 0.510); # used to indicate dry parts of lakes\n\ntex_nosinks = show_region_selection(tstruct_nosinks, trap_color=2, river_color = 3)\ntex_sinks = show_region_selection(tstruct_sinks, trap_color=2, river_color = 3)\n\ndoublesize = tex -> tex[repeat(1:size(tex, 1), 1, 2)'[:],\n                        repeat(1:size(tex, 2), 1, 2)'[:]] # upsampling function\ntex_nosinks = doublesize(tex_nosinks)\ntex_sinks = doublesize(tex_sinks);\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Traps and buildings are then written onto a copy of the textures.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"overlay = copy(Images.imresize(mapimg, size(grid_dtm) .* 2))\noverlay_nosinks = copy(overlay)\noverlay_nosinks[building_mask .== Images.GrayA{Images.N0f8}(1.0, 1.0)] .= white_color\noverlay_nosinks[tex_nosinks .== 2] .= blue_color\noverlay_nosinks[tex_nosinks .== 3] .= blue_color\noverlay_nosinks[river_mask .> Images.Gray{Images.N0f8}(0.0)] .= blue_color\n\noverlay_sinks = copy(overlay)\noverlay_sinks[building_mask .== Images.GrayA{Images.N0f8}(1.0, 1.0)] .= white_color\noverlay_sinks[tex_sinks .== 2] .= blue_color\noverlay_sinks[tex_sinks .== 3] .= blue_color\noverlay_sinks[river_mask .> Images.Gray{Images.N0f8}(0.0)] .= blue_color;\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The result is then visualized with plotgrid.","category":"page"},{"location":"urban/#Without-sinks:","page":"Urban landscape","title":"Without sinks:","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Without sinks, large parts of the terrain, including most backyards, will be inundated. This also include a large part of the road running parallel to the river, as can be seen in the close-up view below.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"sf_nosink, fig_nosinks, sc_nosinks = plotgrid(grid_dtm, texture=overlay_nosinks)\n\nset_camerapos(sc_nosinks, view1...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Close-up view:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(sc_nosinks, view2...)","category":"page"},{"location":"urban/#With-sinks:","page":"Urban landscape","title":"With sinks:","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"With manholes and other sinks, the submerged part of the terrain is significantly reduced, and the road is not flooded.  In this analysis, infiltration has not yet been considered.  Many backyards are still under water.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"sf_sinks, fig_sinks, sc_sinks = plotgrid(grid_dtm, texture=overlay_sinks);\n\nset_camerapos(sc_sinks, view1...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Close-up view:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(sc_sinks, view2...)","category":"page"},{"location":"urban/#Visualize-flow-intensity","page":"Urban landscape","title":"Visualize flow intensity","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The flow intensity at each given point in the terrain depends on the upstream area draining into that point, and how much rain is currently hitting that area.  This also depends on whether upstream lakes have been filled yet or not.  To analyze this, the watercourses function can be used. In addition to the terrain analysis data, the function takes precipitation and infiltration rates as input, as well as a vector indicating the lakes that are currently filled and spilling over.  It returns a field showing the flow intensity field over the whole domain.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"In the call to watercourses below, the unit used when specifying precipitation and infiltration (e.g. mm/hour, which translates into volume/time for a cell with finite area) will also determine the unit used for describing flow intensity (volume per time passing through the cell).","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"# assume all traps already filled\nfilled_traps = fill(false, numtraps(tstruct_sinks))\n\n# compute flow intensity on terrain\nprecip = fill(1.0, size(tstruct_sinks.topography)...) # uniform precipitation field\ninfil = fill(0.0, size(tstruct_sinks.topography)...) # zero infiltration\nrunoff, = watercourses(tstruct_sinks, filled_traps,\n                       precipitation=precip, infiltration=infil);\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The result can be visualized using plotgrid:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"# Plot runoff as a texture on the terrain, using a predefined colormap:\nsf_flow, fig_flow, sc_flow =\n    plotgrid(grid_dtm, texture=runoff,\n             colormap=:Blues)\n\nset_camerapos(sc_flow, view1...)\n\n# Close-up view:\nset_camerapos(sc_flow, view2...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Only a few spots are colored non-white in the above plots.  This is because the flow across the terrain is highly concentrated in a few locations with strong intermittent streams, where the flow values are much higher than elsewhere.   If we want to highlight also the smaller flow patterns, a logarithmic scale can be useful:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"sf_flow_log, fig_flow_log, sc_flow_log =\n    plotgrid(grid_dtm, texture=log10.(runoff), colormap=:Blues)\n\nset_camerapos(sc_flow_log, view1...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Close-up view:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(sc_flow_log, view2...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"On these logarithmic plots, differences between strong and weak flows are attenuated, and it is easier to see how the water flows.","category":"page"},{"location":"urban/#Visualize-upstream-areas","page":"Urban landscape","title":"Visualize upstream areas","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The flow intensity map is useful to identify the areas with high flowrate, but does not indicate the origin of the flow.  The upstream_area function can be used to determine the complete upstream watershed associated with any given cell in the terrain grid. To demonstrate its use, we select a gridcell with high flow rate, and use upstream_area to identify its upstream region.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"max_runoff = extrema(runoff)[2] # the maximum flow value found in the grid\npt = findall(runoff .== max_runoff) # identify the corresponding cell\npt_ix = LinearIndices(grid_dtm)[pt[1]] # convert `pt` (a `CartesianIndex`) to linear index\n\n# Identify cells belonging to the upstream area of `pt`, upsample to twice\n# the grid resolution (to match the resolution of the map texture), and\n# overwrite it on a copy of the map texture using blue color.\nupstream_cells = upstream_area(tstruct_sinks, pt_ix, local_only=false)\ntmp_ind = fill(false, size(grid_dtm))\ntmp_ind[upstream_cells] .= true\ntmp_ind = doublesize(tmp_ind);\nupstream_texture = copy(mapimg)\nupstream_texture[tmp_ind] = 0.5 * blue_color .+ 0.5 .* mapimg[tmp_ind]\n\n# Identify the point `pt` itself in the grid.  We need to upsample this point too.\ntmp_ind = fill(false, size(grid_dtm))\ntmp_ind[pt_ix] = true\ntmp_ind = doublesize(tmp_ind)\npt_ix_upscaled = findall(tmp_ind)\n\n# Flag sink locations in black and the point `pt` in red\nsink_locs = findall(sink_mask .> Images.Gray(0.0))\nupstream_texture[sink_locs] .= black_color\nupstream_texture[pt_ix_upscaled] .= red_color\n\n# Plot the grid\nsf_upstr_log, fig_upstr_log, sc_upstr_log = plotgrid(grid_dtm, texture=upstream_texture)\n\nset_camerapos(sc_upstr_log,\n              CairoMakie.Vec(-17, 202, 178), # observer position\n              CairoMakie.Vec(472, 113, -255), # observer target\n              0.8)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The point pt can be seen in red on the lower left part of this image, and all the black gricells indicate the position of sinks.  The upstream area of pt is indicated with the blue color.  The \"holes\" in this upstream area are caused by the associated sinks.  All the water that falls on the blue are will pass through the point pt.","category":"page"},{"location":"urban/#Infiltration-and-temporal-development","page":"Urban landscape","title":"Infiltration and temporal development","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"A purely static analysis cannot properly capture the temporal aspect of infiltration.  On terrains with permeable surfaces, evaluating whether or not an area gets flooded involves looking at the balance of inflow and infiltration as it develops over time.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Currently, SWIM includes a simplified infiltration model, where infiltration rates depends on spatial location, but remains constant over a defined time interval[2]. By specifying the precipitation intensity (which may vary in space and time), a sequence of events may be computed that shows how terrain fills up, drains or equilbrates over time.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Below, we demonstrate the sequence computation on the terrain twice: first without considering infiltration, then by considering certain parts of terrain permeable with a specified drainage rate.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"We first define a vector of WeatherEvents.  These events indicate points in time when the weather changes.  For example, using two events, we can designate a time where rain with a given rate starts and stops.  Rain rates can be specified as a single number for the whole domain, or as a map of values over the terrain.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"To keep things simple in this demonstration, our \"weather\" vector consists of a single event, where rain starts at hour 0.0, at a uniform rate of 20mm/h across the whole domain.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"weather = [WeatherEvent(0.0, 20 * 1e-3),]","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"For the case with infiltration, we use the precipitation mask, resize it to the grid resolution, convert it to Bool, and multiply it with the infiltration value (25 mm/h).   Note that we here use an infiltration value that is higher than the prescribed rain rate (20mm/h), so areas with will need influx of water from upstream to start filling up.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"pmask = Images.imresize(permeable_mask, size(grid_dtm))\npmask[pmask .!= Images.Gray{Images.N0f8}(0.0)] .= Images.Gray{Images.N0f8}(1.0)\npmask = Matrix{Bool}(pmask .== Images.Gray{Images.N0f8}(1.0));\ninfil = 25.0 * 1e-3 * pmask;\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"We use the result of our static trap analysis with sinks to compute the time sequence.  In other words, the city drainage system is here considered able to evacuate all water that enters manholes, etc.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"seq1 = fill_sequence(tstruct_sinks, weather) # result with no infiltration\nseq2 = fill_sequence(tstruct_sinks, weather, infiltration=infil); # result with infiltration\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"By looking at the timestamp for the last event in the sequence, we can assess the time it takes in the two cases before steady state is reached (i.e. all traps filled up, or reached equilibrium).","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"(seq1[end].timestamp, seq2[end].timestamp)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Without infiltration, the end state is here reached in 37 hours, whereas it takes more than 132 hours when infiltration is included.","category":"page"},{"location":"urban/#Visualize-time-sequence","page":"Urban landscape","title":"Visualize time sequence","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Using the generated sequence of events, we can visualize the gradual accumulation (or depletion) of water on the terrain by creating a series of \"snapshot\" textures at specified timepoints, and then draping them over the terrain in the viewer.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"First, we create a texture that we will use as background image when drawing the updates.  For this, we use map image, and paint the river blue.  As we will visualize two cases, we make two copies of this texture.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"animated_overlay_1 = copy(mapimg);\nanimated_overlay_1[river_mask .> Images.Gray{Images.N0f8}(0.0)] .= blue_color;\nanimated_overlay_2 = copy(animated_overlay_1)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"We now specify the time steps for which we want to visualize the state of the terrain. Since the most rapid and interesting changes happen early, we here visualize the first two hours.  We compute 100 textures, equidistant in time.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"t_end = 2.0 # specify the time at the end of the visualized period (2 hours)\ntimepoints = collect(range(0.0, t_end, length=100)); # specify the timepoints\nnothing #hide","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"The function interpolate_timeseries is used to compute the 100 textures. Since the returned textures have the resolution of the grid, whereas we want to superimpose them on the animated_overlay texture which has twice the resolution, we reuse the doublesize function that we defined earlier:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"series1, = interpolate_timeseries(tstruct_sinks, seq1, timepoints, verbose=false)\nseries2, = interpolate_timeseries(tstruct_sinks, seq2, timepoints, verbose=false)\n\n# The following code block plots the 3D grid and then\nsurface1, f1, sc1 = plotgrid(grid_dtm, texture = animated_overlay_1)\nsurface2, f2, sc2 = plotgrid(grid_dtm, texture = animated_overlay_2)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"When using GLMakie, the surfaces can be displayed in separate windows as follows: display(CairoMakie.Screen(), f1) display(CairoMakie.Screen(), f2)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"for i = 1:length(timepoints)\n    s1, s2 = doublesize(series1[i]), doublesize(series2[i])\n\n    # filled part of traps\n    animated_overlay_1[s1[:] .== 1] .= blue_color\n    animated_overlay_2[s2[:] .== 1] .= blue_color\n\n    # rivers\n    animated_overlay_1[s1[:] .== 3] .= blue_color\n    animated_overlay_2[s2[:] .== 3] .= blue_color\n\n    # Parts of lakes that are still not submerged\n    animated_overlay_1[s1[:] .== 2] = 0.5 * mapimg[s1[:] .== 2] .+ 0.5 .* beige_color;\n    animated_overlay_2[s2[:] .== 2] = 0.5 * mapimg[s2[:] .== 2] .+ 0.5 .* beige_color;\n\n    # update textures on surfaces\n    drape_surface(surface1, animated_overlay_1)\n    drape_surface(surface2, animated_overlay_2)\n\n    # brief pause\n    sleep(0.05)\nend","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Although the animation above can not be shown directly in the online documentation, we can show the end states.  To better see the differences, we use closeup views:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(sc1, view2...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Terrain state at end of animated period, assuming no infiltration.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"set_camerapos(sc2, view2...)","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Terrain state at end of animated period, including the effect of infiltration.","category":"page"},{"location":"urban/#Conclusion","page":"Urban landscape","title":"Conclusion","text":"","category":"section"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"At this point we conclude this demonstration of some main elements of SWIM:","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"Loading and preparation of data\nStatic analysis (identification of trap hierarchies and flow patterns, for a given surface, infrastructure and sinks)\nUsing the result of static analysis to visualize flow patterns and identify upstream areas.\nInfiltration and simulating temporal developments.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"[1]: The data used in this example was originally obtained from Kartverket (the Norwegian Mapping Authority) under the Creative Commons Attribution 4.0 International (CC BY 4.0) license.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"[2]: This assumption may be relaxed by introducing new, updated infiltration rates at fixed points in time.","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"","category":"page"},{"location":"urban/","page":"Urban landscape","title":"Urban landscape","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Index","title":"Index","text":"","category":"page"},{"location":"indexlist/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexlist/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#What-is-SWIM?","page":"Introduction","title":"What is SWIM?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SWIM (Surface Water Integrated Modeling) is an open-source software package for static modeling and prediction of surface water and urban flooding based on analysis of terrain topography. It is developed and maintained by the Applied Computational Science research group at SINTEF Digital.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SWIM consists of a collection of algorithms for analysing terrain, identifying watershed boundaries, and providing a better understanding of how water accumulates and moves through the landscape. This is valuable for various purposes, such as water resource management, flood modeling, and environmental planning.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Our algorithms originate from work on CO2 storage and are based on an assumption of infinitesimal flow. These so-called spill-point analyses were later modified to model flooding in urban areas. Spill-point analyses are highly computationally efficient compared to tools based on numerical simulation. This makes it easy to work interactively and test out various scenarios and measures. SWIM offers some unique functionality, such as simplified infiltration models (both permeable and impermeable surfaces) and the calculation of time series that models how water accumulates or drains over time, without having to resort to computationally intensive numerical time-stepping approaches.","category":"page"},{"location":"#Functionality","page":"Introduction","title":"Functionality","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SWIM is a set of tools that is intended to provide a flexible foundation for further development. Current functionality includes:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Static surface models\nCalculation of catchment areas, waterways, and hierarchical networks of intermittent streams, ponds and lakes\nAccumulation areas for water, topological network of ponds, and how they connect and merge together\nPermanent water volumes such as rivers, lakes, and seas\nDynamic analysis\nTerrain response to precipitation events and infiltration over time\nRouting of water as ponds overflow\nTerrain characteristics and infrastructure\nBuildings, obstacles, drainage, and measures\nSimplified infiltration model that supports both permeable and impermeable surfaces\nBasic IO and visualization routines","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: image)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"System of lakes and rivers identified in the watershed analysis.","category":"page"},{"location":"#Learn-more","page":"Introduction","title":"Learn more","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The best way to get introduced to SWIM is probably to have a look at the provided examples. The Urban landscape example provides an introduction to key SWIM functionality applied to a real dataset of a district in central Oslo.  The Simple synthetic example uses an extremely simplified surface to explain and demonstrate some key concepts.  The Handling flat areas example is a small example to show how large, flat water bodies can be identified and kept separate from the analysis.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is registered in the Julia package registry, and can be installed using:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\n(@1.11) pkg> add SurfaceWaterIntegratedModeling","category":"page"},{"location":"utils/#Utilities-and-visualization","page":"Utilities and visualization","title":"Utilities and visualization","text":"","category":"section"},{"location":"utils/","page":"Utilities and visualization","title":"Utilities and visualization","text":"Modules = [SurfaceWaterIntegratedModeling]\nPages = [\"watercourses.jl\", \"utils.jl\", \"IOandplot.jl\"]","category":"page"},{"location":"utils/#SurfaceWaterIntegratedModeling.saturated_spillgraph-Tuple{TrapStructure}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.saturated_spillgraph","text":"saturated_spillgraph(tstruct)\n\nCreate the spillgraph corresponding to the provided trapping structure, considering that all traps are already filled.\n\nThe result will be returned as a SimpleDiGraph showing which traps are spilling into which traps or regions.  \n\nThe trapping structure tstruct may have regions with negative indices (referring to regions that spill out of the terrain).  Since SimpleDiGraph does not handle nodes with negative indices, a remapping is necessary between the indices used in tstruct and the set 1:N used in the returned graph. These mappings are returned as the second and third return value:\n\nThe second return value is a Vector{Int} mapping from 1:N to the indices  in tstruct\nThe third return value is a Dict mapping from the indices in tstruct to  1:N.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.watercourses-Tuple{TrapStructure, Vector{Bool}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.watercourses","text":"watercourses(tstruct, full_traps, precipitation, infiltration)\n\nCompute the total intensity of flow of water across all non-lake grid cells in the terrain.\n\nDetermine the areas containing high amounts of flowing water, and return a grid with the corresponding values.\n\nArguments\n\ntstruct::TrapStructure: a TrapStructure object containing all the information from                            the topographical analysis, as returned by the                           spillanalysis function.\nfull_traps::Vector{Bool}: A vector with one entry per (sub)trap, indicating                              whether this trap has been filled yet or not.  Only full                             traps will overflow and forward the water from upstream.\nprecipitation::Matrix{<:Real}: A grid expressing precipitation rate per grid cell.                                   If left empty, it will be substituted by a grid                                    filled with ones.\ninfiltration::Matrix{<:Real}: A grid expressing the maximum infiltration rate                                  per grid cell.  If left empty, it will be substituted                                 by a grid filled with zeros.\n\nReturns\n\nrunoff::Matrix{Float64}: Grid expressing infiltration excess runoff rate                             (positive values)                             or remaining infiltration capacity (negative values)\nregion_accum::Vector{Float64}: Vector with one entry per spill region, indicating                         net water accumulation rate for that region (also including                         water spilling into the region from upstream filled traps).                          Note that if the region is associated with a filled trap,                          the accumulation value is set to zero, unless it spills into                         a filled 'sibling' trap.  The logic is in any case such that                          the accumulation of any still unfilled trap should equal                         the sum of accumulation of its regions.\noffregion_runoff::Float64: Total rate of water flowing off the domain\nused_infiltration::Float64: Total infiltration rate across the terrain\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.all_subtraps_of-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Union{Int64, Vector{Int64}}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.all_subtraps_of","text":"all_subtraps_of(subtrap_graph, trap_ixs)\n\nReturn all subtraps (at any level) of a specified set of traps.\n\nThe graph representing the supertrap/subtrap tree is given by subtrap_graph.  The indices to the set of traps is specified by trap_ixs.  This argument may be an integer refering to a single trap, or a Vector{Int} referring to  one or more traps.\n\nThe result is returned as a Vector{Int} giving the indices of all traps that  are subtraps of the trap(s) referred to by trap_ixs.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.all_upstream_regions-Tuple{TrapStructure, Int64}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.all_upstream_regions","text":"all_upstream_regions(tstruct, region)\n\nIdentify all spill regions that will eventually become part of the extended watershed of a specified region.\n\nWhen traps are empty, water accumulates locally.  As traps fill up, water starts to spill from upstream to downstream regions.  This function identifies all the spill regions that will flow into a specified region/trap when all upstream traps have been completely filled.\n\nThe result is returned as a Vector{Int}, giving the indices of all regions  that will be upstream of the specified region when all traps are filled.\n\nArguments\n\ntstruct::TrapStructure{<:Real}: trap structure object describing the terrain traps\nregion::Int: index of the region in question\n\nSee also upstream_area\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.compute_spillfield_graph-Tuple{Matrix{Int8}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.compute_spillfield_graph","text":"compute_spillfield_graph(spillfield::Matrix{Int8})\n\nCompute a Graphs.SimpleDiGraph representation from a spillfield matrix.\n\nThe spillfield variable is a matrix that can be generated by the  spillfield function.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.flatten_grid!-Tuple{Matrix{<:Real}, Matrix{<:Bool}, Symbol}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.flatten_grid!","text":"flatten_grid!(grid::Matrix{<:Real}, mask::Matrix{<:Bool}, height_choice::Symbol)\n\nFlatten indicated areas of a terrain grid.\n\nThe grid grid represents height values of a terrain, and will be modified by the function.  The mask is a similarly sized, boolean grid that identifies which areas should be flattened (all cells with value true).  Each such connected region is then assigned a fixed height value and grid is modified accordingly.  \n\nThere are three ways of computing the height, indicated by the height_choice argument.  Valid options are:\n\n:min - the height of each flat area becomes the minimum value of its grid cells\n:max - the height of each flat area becomes the  maximum value of its grid cells\n:mean - the height of each flat area becomes the mean value of its grid cells\n\nSee also: identify_flat_areas\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.identify_flat_areas","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.identify_flat_areas","text":"identify_flat_areas(grid, rel_tol, min_cluster_size, lengths=nothing)\n\nIdentify areas in the grid that are flat within a specified tolerance.  Can be used to detect lakes in a terrain.\n\nReturns a boolean grid of same shape as the input grid, where cells that are  considered to belong to flat areas are flagged as 'true' (rest are false).\n\nArguments\n\ngrid::Matrix{<:Real}: terrain raster grid with height values\nrel_tol::Real: tolerance to use in determine when a slope between two grid                  cells may be considered 'flat'.  The tolerance is specified                  relatively to the maximum slope present in the grid.\nmin_cluster_size::Int: Specify how large an agglomeration of \"flat\" cells                          needs to be (in terms of number of cells) in order                           to be included in the result.  This is used to                           filter out small fragments that are not considered                           important.\nlengths::Tuple{Int, Int}: Specify the length of the grid in x and y                             directions.  This is needed to correctly handle                            the aspect ratio when computing slopes.  If no                             argument provided, the resolution of the grid                             is used as a substitute.\n\nSee also: flatten_grid!\n\n\n\n\n\n","category":"function"},{"location":"utils/#SurfaceWaterIntegratedModeling.interpolate_timeseries-Tuple{TrapStructure, Vector{SpillEvent}, Vector{<:Real}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.interpolate_timeseries","text":"interpolate_timeseries(tstruct, seq, timepoints; \n                       filled_color=1, trap_color=2, river_color=3)\n\nCompute the exact terrain fill states for a sequence of timepoints, given a trapping structure and sequence of SpillEvents.\n\nEach generated fill state is represented as an integer matrix (Matrix{Int}), where submerged cells are set to filled_color, the parts of traps that are not (yet) submerged set to trap_color and intermittent streams set to river_color.  Other cells are attributed the value zero.\n\nThe result is returned as a Vector{Matrix{Int}}, of the same length as timepoints.  A second return value provides a corresponding Vector{Int} that for each timepoint provides the index for the latest preceding event in seq.\n\nArguments\n\ntstruct::TrapStructure{<:Real}: trap structure object describing the terrain traps\nseq::Vector{SpillEvent}: the sequence of events, as computed by                             fill_sequence for a given weather scenario\ntimepoints::Vector{<:Real}: the timepoints for which we want to compute the exact                               terrain fill states.  Should be given in ascending                               order.\nfilled_color::Int: The 'color' value to represent filled areas (default: 1).\ntrap_color::Int: The 'color' to represent unfilled parts of traps (default: 2).\nriver_color::Int: The 'color' to represent intermittent rivers (default: 3).\nverbose::Bool: Whether to print progess information during computations (default: true).\n\nSee also spillanalysis, fill_sequence,  trap_states_at_timepoints.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.show_region_selection-Tuple{TrapStructure}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.show_region_selection","text":"show_region_selection(tstruct; selection=nothing, \n                      region_color=1, trap_color=2, river_color=3)\n\nCreate a texture identifying the requested regions, traps and related rivers.\n\nThe information about the terrain, including topography, spillpoints, etc., is provided by the structure tstruct, which can be obtained from the spillanalysis function.  The selected regions are identified by selection, a vector with the indices of the selected regions.  If left empty, all toplevel traps/regions will be selected.  \n\nThe result is returned as a matrix of integers, where the integers can be thought of as 'colors'. The integer values used to indicate region, trap or river are given by the arguments region_color, trap_color and river_color, respectively.  If region_color is a negative integer, each region will be assigned an unique color, starting from abs(region_color) and incrementing by one per region.\n\nArguments\n\nselection: integer vector containing indices of the selected regions\nregion_color: integer to assign to the cells of all selected regions\ntrap_color: integer to assign to all selected traps \nriver_color: integer to assign to all river cells related to the selected                regions\n\nSee also: spillanalysis\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.toplevel_traps-Tuple{Graphs.SimpleGraphs.SimpleDiGraph}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.toplevel_traps","text":"toplevel_traps(subtrap_graph)\n\nIdentify all top-level traps in the given subtrap graph.\n\nTop-level traps are those that those that are not subtraps of yet larger lakes. The result is returned as a vector of indices to those traps.\n\nArguments\n\nsubtrap_graph::Graphs.SimpleDiGraph: oriented graph expressing the trap/subtrap                                         graph structure.  If A is a subtrap of B, there                                         will be an edge pointing from A to B.  As such,                                         the toplevel traps are those with not outwards-                                        pointing edges.\n\nSee also: sshierarchy!\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.trap_states_at_timepoints-Tuple{TrapStructure, Vector{SpillEvent}, Vector{<:Real}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.trap_states_at_timepoints","text":"trap_states_at_timepoints(tstruct, seq, timepoints)\n\nCompute the exact amount of water in all traps for a specific set of timepoints, given a trapping structure and sequence of SpillEvents.\n\nThe result is returned as a vector of three-element tuples, with one entry per timepoint.  \n\nThe first element of the tuple is a Vector{Bool} with one entry per trap, indicating if the trap is filled or not at the specified timepoint.\nThe second element is a Vector{Real} with one entry per trap, giving the  amount of water in that trap at the specified timepoint.\nThe third element is an index into seq, pointing to the last SpillEvent to occur before the timepoint.\n\nArguments\n\ntstruct::TrapStructure{<:Real}: trap structure object describing the terrain traps\nseq::Vector{SpillEvent}: the sequence of events, as computed by                             fill_sequence for a given weather scenario\ntimepoints::Vector{<:Real}: the timepoints for which we want to compute the exact                               water amounts of the traps.  Should be given in                                ascending order.\nverbose::Bool: Whether to print progess information during computations (default: true).\n\nSee also spillanalysis, fill_sequence,  interpolate_timeseries.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.upstream_area-Tuple{TrapStructure, Int64}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.upstream_area","text":"upstream_area(tstruct, point, local_only=true)\n\nDetermine all grid cells belonging to the upstream area of a given point location in the terrain grid.\n\nResult is returned as a Vector{Int}, giving the linear indices of the terrain  grid cells that constitute the upstream area of the specified point.\n\nArguments\n\ntstruct::TrapStructure{<:Real}: trap structure object describing the terrain traps\npoint::Int: linear index to the terrain grid cell for which the upstream area               is requested\nlocal_only::Bool: if true, consider only the immediate spill region.  If                      otherwise, consider also upstream spill regions.\n\nSee also all_upstream_regions.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.drape_surface-Tuple{Any, Any}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.drape_surface","text":"drape_surface(surf, tex)\n\nUpdate the texture of a surface drawn with plotgrid. Here, surf is a mesh object (first return value of plotgrid,  whereas tex can be a matrix of numbers or of Colorant (see plotgrid  documentation for specifics).\n\nSee also plotgrid.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.loadgrid-Tuple{String}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.loadgrid","text":"loadgrid(filename, delimiter)\n\nLoad a 2D grid saved in csv format, with a specified delimiter separating  individual entries.  Returns a Matrix{Real}.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.plotgrid-Tuple{AbstractMatrix{<:Real}}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.plotgrid","text":"plotgrid(grid, texture=nothing, colormap=:lightrainbow, wireframe=false, \n         downsamplefac=1, heightfac=1, colorrange=nothing)\n\nPlot a texture-mapped 2½D surface of a given grid, using Makie.\n\nThe function returns three values in the following order: \n\nthe surface object\nthe figure\nthe scene\n\nArguments\n\ngrid::AbstractArray{<:Real, 2}: 2D array representing the grid\ntexture::Union{Matrix{<:Union{Real, Colorant}}, Nothing}:     optional texture for the grid.  This can be presented as a matrix of    Colorant (directly representing colors), or of numbers (in which case the    prevailing colormap and colorrange are used to specify the actual    colors).  If texture is left to nothing, the height values of grid     will be directly used as a substitute.\ncolormap::Union{Symbol, ColorScheme}=:lightrainbow:     specifies the colormap to use if the texture is provided as a matrix     of numbers.  It can either be a symbol referring to a specific colormap    used by Makie (call Makie.available_gradients() for a list of available    colormap symbols), or directly provided as a ColorScheme.  Note that     if texture is given as a Matrix{Colorant}, then colormap has no     effect.\nwireframe::Bool: option to display wireframe grid\ndownsamplefac::Real: scaling factor for downsampling the grid. Useful for                        rapid visualization of very large grids.\nheightfac::Real: Scaling factor for height values of the grid\ncolorrange::Tuple{<:Real, <:Real}: specify the values representing the start                                      and end points of colormap\n\nSee also drape_surface\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.savegrid-Tuple{String, Any}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.savegrid","text":"savegrid(filename, matrix, delimiter)\n\nSave the 2D grid represented by matrix to the csv file with name filename,  using a specified character as delimiter.\n\n\n\n\n\n","category":"method"},{"location":"utils/#SurfaceWaterIntegratedModeling.set_camerapos-NTuple{4, Any}","page":"Utilities and visualization","title":"SurfaceWaterIntegratedModeling.set_camerapos","text":"set_camerapos(scene, cpos, ctarget, czoom)\n\nSet the camera position, target and zoom level for a given scene.\n\nThis function is provided as a workaround to smooth over different idiosyncracies in camera handling for the Makie backends GLMakie and  CairoMakie.\n\n\n\n\n\n","category":"method"}]
}
